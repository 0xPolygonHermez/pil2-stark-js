pragma circom 2.1.0;
pragma custom_templates;

include "mux2.circom";
include "mux1.circom";
include "iszero.circom";
include "recursive2.verifier.circom";

<% let nPublics = starkInfoBasic.nPublics; -%>
<% let numChallengesStage = starkInfoBasic.numChallenges; -%>
<% let nChallenges = starkInfoBasic.numChallenges.reduce((curr, acc) => curr + acc, 0) + 4; -%>
<% let nStepsFRI = starkInfoBasic.starkStruct.steps.length; -%>

// Given a circuit type, return the corresponding verification key
template SelectVerificationKey() {

    // 0 -> Null
    // 2 -> Recursive2
    // 3 -> Basic1 (Recursive1)
    // 4 -> Basic2 (Recursive1)
    // ...
    signal input circuitType;

    // Verification key corresponding to the circuit type
    signal output verificationKey[4];

    // Check that circuit type is valid value between 0 and N
    signal b0 <== circuitType * (circuitType - 1);
<% for(let i = 0; i < vks.length - 1; i++) { -%>
<%  if(i < vks.length - 2) { -%>
    signal b<%- i + 1 %> <== b<% i %> * (circuitType - <%- i + 2 %>);
<%  } else { -%>
    b<%- i %> * (circuitType - <%- i + 2 %>) === 0;
<% } -%>
<% } -%>

    // The idea is to store an array of booleans which will indicate either 0 or 1 depending if the circuit type is equal to the index
    // For instance, [0,1,0,0] would mean that the circuit type is a recursive2.
    // Then, we will calculate the verification key as the sum of all the verification keys multiplied by the corresponding boolean
    signal isType[<%- vks.length + 1 %>];
<% for(let i = 0; i < vks.length + 1; i++) { -%>
    isType[<%- i %>] <== IsZero()(<%- i %> - circuitType);
<% } -%>

    signal verificationKeys[<%- vks.length + 1 %>][4];
    verificationKeys[0] <== [0,0,0,0];
<% for(let i = 0; i < vks.length; i++) { -%>
    verificationKeys[<%- i + 1 %>] <== [<%- vks[i].join(', ') %>];
<% } -%>

    signal accVK[<%- vks.length + 1 %>][4];

    for(var i = 0; i < <%- vks.length + 1 %>; i++) {
        if(i == 0) {
            for(var j = 0; j < 4; j++) {
                accVK[i][j] <== isType[i]*verificationKeys[i][j];
            }
        } else {
            for(var j = 0; j < 4; j++) {
                accVK[i][j] <== isType[i]*verificationKeys[i][j] + accVK[i - 1][j];
            }
        }
    }

    verificationKey <== accVK[<%- vks.length %>];
}

template Main() {

    signal input publics[<%- nPublics %>];

    signal input challenges[<%- nChallenges %>][3];

    signal input challengesFRISteps[<%- nStepsFRI + 1 %>][3];

    signal input circuitType;
    signal input aggregationType;

    signal input subAirValue[3];

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    signal input root<%- i+1 %>[4];
<% } -%>
    signal input rootQ[4];

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    signal input s0_vals<%- i+1 %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`cm${i+1}`] %>];
<% } -%>
    signal input s0_valsQ[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`cmQ`] %>];
    signal input s0_valsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.nConstants %>];

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    signal input s0_siblings<%- i+1 %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];
<% } -%>
    signal input s0_siblingsQ[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];
    signal input s0_siblingsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];

    signal input evals[<%- starkInfo.evMap.length %>][3];

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input s<%- i %>_root[4];
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input s<%- i %>_vals[<%- starkInfo.starkStruct.nQueries %>][<%- (1 << (starkInfo.starkStruct.steps[i-1].nBits - starkInfo.starkStruct.steps[i].nBits))*3 %>];
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input s<%- i %>_siblings[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[i].nBits %>][4];
<% } -%>

    signal input finalPol[<%- 1 << starkInfo.starkStruct.steps[starkInfo.starkStruct.steps.length-1].nBits %>][3];

<%  let transcriptValues = ["aggregationType", "subAirValue"]; -%>
    signal input sv_publicsHash[3];
<%  transcriptValues.push("sv_publicsHash"); -%>
<%  for (let i = 0; i < numChallengesStage.length; ++i) { -%>
    signal input sv_root<%- i+1 %>[3];
<%      transcriptValues.push(`sv_root${i+1}`); -%>
<%  } -%>
    signal input sv_rootQ[3];
<%      transcriptValues.push(`sv_rootQ`); -%>
    signal input sv_evalsHash[3];
<%  transcriptValues.push("sv_evalsHash"); -%>
<%      for(let i = 1; i < nStepsFRI; i++) { -%>
    signal input sv_s<%- i %>_root[3];
<%  transcriptValues.push(`sv_s${i}_root`); -%>
<%      } -%>
    signal input sv_finalPolHash[3];
<%  transcriptValues.push("sv_finalPolHash"); -%>

    component sv = StarkVerifier();
    
    sv.rootC <== SelectVerificationKey()(circuitType);

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    sv.root<%- i+1 %> <== root<%- i + 1 %>;
<% } -%>
    sv.rootQ <== rootQ;

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    sv.s0_siblings<%- i+1 %> <== s0_siblings<%- i+1 %>;
<% } -%>
    sv.s0_siblingsQ <== s0_siblingsQ;
    sv.s0_siblingsC <== s0_siblingsC;

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    sv.s0_vals<%- i+1 %> <== s0_vals<%- i+1 %>;
<% } -%>
    sv.s0_valsQ <== s0_valsQ;
    sv.s0_valsC <== s0_valsC;

    sv.evals <== evals;
    
<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    sv.s<%- i %>_root <== s<%- i %>_root;
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    sv.s<%- i %>_siblings <== s<%- i %>_siblings;
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    sv.s<%- i %>_vals <== s<%- i %>_vals;
<% } -%>

    sv.finalPol <== finalPol;

    for(var i = 0; i < <%- nPublics %>; i++) {
        sv.publics[i] <== publics[i];
    }

<%  let nPublicsInps = nPublics; -%>
    for(var i = 0; i < <%- nChallenges %>; i++) {
        sv.publics[<%- nPublicsInps %> + 3*i] <== challenges[i][0];
        sv.publics[<%- nPublicsInps %> + 3*i+1] <== challenges[i][1];
        sv.publics[<%- nPublicsInps %> + 3*i+2] <== challenges[i][2];
    }
<%  nPublicsInps += nChallenges*3; -%>

    for(var i = 0; i < <%- nStepsFRI + 1 %>; i++) {
        sv.publics[<%- nPublicsInps %> + 3*i] <== challengesFRISteps[i][0];
        sv.publics[<%- nPublicsInps %> + 3*i+1] <== challengesFRISteps[i][1];
        sv.publics[<%- nPublicsInps %> + 3*i+2] <== challengesFRISteps[i][2];
    }
<%  nPublicsInps += (nStepsFRI + 1)*3; -%>

<%  for(let i = 0; i < 4; i++) { -%>
    sv.publics[<%- nPublicsInps++ %>] <== <%- vks[1][i] %>;
<%  } -%>

    sv.publics[<%- nPublicsInps++ %>] <== circuitType;
    sv.publics[<%- nPublicsInps++ %>] <== aggregationType;

    for(var i = 0; i < 3; i++) {
        sv.publics[<%- nPublicsInps %> + i] <== subAirValue[i];
    }
<%  nPublicsInps += 3 -%>

    sv.publics[<%- nPublicsInps++ %>] <== sv_publicsHash[0];
    sv.publics[<%- nPublicsInps++ %>] <== sv_publicsHash[1];
    sv.publics[<%- nPublicsInps++ %>] <== sv_publicsHash[2];

<%  for (let i = 0; i < numChallengesStage.length; i++) { -%>
    for(var i = 0; i < 3; i++) {
        sv.publics[<%- nPublicsInps %> + i] <== sv_root<%- i+1 %>[i];
    }

<%  nPublicsInps += 3 -%>
<%  } -%>
    for(var i = 0; i < 3; i++) {
        sv.publics[<%- nPublicsInps %> + i] <== sv_rootQ[i];
    }

<%  nPublicsInps += 3 -%>
    sv.publics[<%- nPublicsInps++ %>] <== sv_evalsHash[0];
    sv.publics[<%- nPublicsInps++ %>] <== sv_evalsHash[1];
    sv.publics[<%- nPublicsInps++ %>] <== sv_evalsHash[2];

<%  for(let i = 1; i < nStepsFRI; i++) { -%>
    for(var i = 0; i < 3; i++) {
        sv.publics[<%- nPublicsInps %> + i] <== sv_s<%- i %>_root[i];
    }

<%  nPublicsInps += 3 -%>
<%  } -%>
    sv.publics[<%- nPublicsInps++ %>] <== sv_finalPolHash[0];
    sv.publics[<%- nPublicsInps++ %>] <== sv_finalPolHash[1];
    sv.publics[<%- nPublicsInps++ %>] <== sv_finalPolHash[2];
    
}

<% const publics = ["publics", "challenges", "challengesFRISteps"]; -%>
<% publics.push(...transcriptValues); -%>
component main {public [<%- publics.join(",") %>]} = Main();
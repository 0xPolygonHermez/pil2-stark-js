pragma circom 2.1.0;
pragma custom_templates;

include "mux2.circom";
include "mux1.circom";
include "iszero.circom";
include "<%- verifierCircuitName %>.verifier.circom";

// Given a circuit type, return the corresponding verification key
template SelectVerificationKey() {

    // 0 -> Null
    // 1 -> Recursive2
    // 2 -> Basic1 (Recursive1)
    // 3 -> Basic2 (Recursive1)
    // ...
    signal input circuitType;

    // Recursive2 verification key. It needs to be provided as input because it is not known at compile time
    signal input rootCRecursive2[4];

    // Verification key corresponding to the circuit type
    signal output verificationKey[4];

    // The idea is to store an array of booleans which will indicate either 0 or 1 depending if the circuit type is equal to the index
    // For instance, [0,1,0,0] would mean that the circuit type is a recursive2.
    // Then, we will calculate the verification key as the sum of all the verification keys multiplied by the corresponding boolean
    signal isType[<%- vks.length + 2%>];
<%  let sum = []; -%>
<% for(let i = 0; i < vks.length + 2; i++) { -%>
<%  sum.push(`isType[${i}]`); -%>
    isType[<%- i %>] <== IsZero()(<%- i %> - circuitType);
<% } -%>

    // Check that the type is supported
    <%- sum.join(" + ") %> === 1;

    signal verificationKeys[<%- vks.length + 2 %>][4];
    verificationKeys[0] <== [0,0,0,0];
    verificationKeys[1] <== rootCRecursive2;
<% for(let i = 0; i < vks.length; i++) { -%>
    verificationKeys[<%- i + 2 %>] <== [<%- vks[i].join(', ') %>];
<% } -%>

    signal accVK[<%- vks.length + 2 %>][4];

    for(var i = 0; i < <%- vks.length + 2 %>; i++) {
        if(i == 0) {
            for(var j = 0; j < 4; j++) {
                accVK[i][j] <== isType[i]*verificationKeys[i][j];
            }
        } else {
            for(var j = 0; j < 4; j++) {
                accVK[i][j] <== isType[i]*verificationKeys[i][j] + accVK[i - 1][j];
            }
        }
    }

    verificationKey <== accVK[<%- (vks.length + 2) - 1 %>];
}

template AggregateValues() {
    signal input valueA[4];
    signal input valueB[4];
    signal input {binary} isNullA; // 1 if is circuit type A is 0 (null), 0 otherwise
    signal input {binary} isNullB; // 1 if is circuit type B is 0 (null), 0 otherwise

    signal output valueAB[4];

    // Calculate the hash of valueA and valueB
    signal hash[12] <== Poseidon(12)([valueA[0], valueA[1], valueA[2], valueA[3], valueB[0], valueB[1], valueB[2], valueB[3]], [0,0,0,0]);
    signal hashAB[4] <== [hash[0], hash[1], hash[2], hash[3]];

    // If valueA or valueB is [0,0,0], it means that the particular subproof does not have that stage. Therefore we should proceed the same way as if circuitType is null
    signal isValueA1Zero <== IsZero()(valueA[0]);
    signal isValueA2Zero <== IsZero()(valueA[1]);
    signal isValueA3Zero <== IsZero()(valueA[2]);
    signal isValueA4Zero <== IsZero()(valueA[3]);
    signal isValueAZero <== IsZero()(4 - (isValueA1Zero + isValueA2Zero + isValueA3Zero + isValueA4Zero));

    signal isValueB1Zero <== IsZero()(valueB[0]);
    signal isValueB2Zero <== IsZero()(valueB[1]);
    signal isValueB3Zero <== IsZero()(valueB[2]);
    signal isValueB4Zero <== IsZero()(valueB[3]);
    signal isValueBZero <== IsZero()(4 - (isValueB1Zero + isValueB2Zero + isValueB3Zero + isValueB4Zero));


    // If circuit type A is null || valueA === 0 and circuit type B is null || valueB === 0, then the valueAB is 0
    // If circuit type A is not null && valueA !== 0 and circuit type B is null || valueB === 0, then the valueAB is valueA
    // If circuit type A is null || valueA === 0 and circuit type B is not null && valueB !== 0, then the valueAB is valueB
    // If circuit type A is not null && valueA !== 0 and circuit type B is not null && valueB !== 0, then the valueAB is hashAB

    signal {binary} s[2] <== [(1 - isNullA)*(1 - isValueAZero), (1 - isNullB)*(1 - isValueBZero)];
    valueAB <== MultiMux2(4)([[0,0,0,0], valueA, valueB, hashAB], s);

}

template AggregateSubAirValues() {
    signal input subAirValueA[3];
    signal input subAirValueB[3];
    signal input {binary} isNullA; // 1 if is circuit type A is 0 (null), 0 otherwise 
    signal input {binary} isNullB; // 1 if is circuit type B is 0 (null), 0 otherwise 

    signal input {binary} aggregationType; // 1 if aggregation is multiplication, 0 if aggregation is addition

    signal output subAirValueAB[3];

    // If circuit type A is null, then its subAirValue is zero;
    signal valueA[3] <== [ (1 - isNullA)*subAirValueA[0], (1 - isNullA)*subAirValueA[1], (1 - isNullA)*subAirValueA[2] ];

    // If circuit type B is null, then its subAirValue is zero;
    signal valueB[3] <== [ (1 - isNullB)*subAirValueB[0], (1 - isNullB)*subAirValueB[1], (1 - isNullB)*subAirValueB[2] ];

    signal values[2][3];
    values[0] <== [valueA[0] + valueB[0], valueA[1] + valueB[1], valueA[2] + valueB[2]];
    values[1] <== [valueA[0] * valueB[0], valueA[1] * valueB[1], valueA[2] * valueB[2]];

    // Either add or multiply the subAirValues according to the aggregation type and then return the result
    subAirValueAB <== MultiMux1(3)(values, aggregationType);
}

template Main() {

    signal input publics[<%- nPublics %>];

    signal input aggregationTypes[<%- nSubAirValues %>];

    signal input challenges[<%- nChallengesStages.reduce((nc, acc) => nc + acc, 0) + 4 %>][3];

    signal input challengesFRISteps[<%- stepsFRI.length + 1 %>][3];

    signal input rootCRecursive2[4];

<%  let circuits = ["A", "B"]; -%>
<%  for(let i = 0; i < circuits.length; ++i) { -%>
<%      let c = circuits[i] -%>
    signal input s<%- c %>_circuitType;

    signal input s<%- c %>_subAirValues[<%- nSubAirValues %>][3];

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    signal input s<%- c %>_root<%- i + 1 %>[4];
<% } -%>
    signal input s<%- c %>_rootQ[4];

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    signal input s<%- c %>_s0_vals<%- i+1 %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`cm${i+1}`] %>];
<% } -%>
    signal input s<%- c %>_s0_valsQ[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`cmQ`] %>];
    signal input s<%- c %>_s0_valsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.nConstants %>];

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    signal input s<%- c %>_s0_siblings<%- i+1 %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];
<% } -%>
    signal input s<%- c %>_s0_siblingsQ[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];
    signal input s<%- c %>_s0_siblingsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];

    signal input s<%- c %>_evals[<%- starkInfo.evMap.length %>][3];

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input s<%- c %>_s<%- i %>_root[4];
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input s<%- c %>_s<%- i %>_vals[<%- starkInfo.starkStruct.nQueries %>][<%- (1 << (starkInfo.starkStruct.steps[i-1].nBits - starkInfo.starkStruct.steps[i].nBits))*3 %>];
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input s<%- c %>_s<%- i %>_siblings[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[i].nBits %>][4];
<% } -%>

    signal input s<%- c %>_finalPol[<%- 1 << starkInfo.starkStruct.steps[starkInfo.starkStruct.steps.length-1].nBits %>][3];

    signal input s<%- c %>_sv_rootCHash[4];
<%  for (let i = 0; i < nChallengesStages.length; ++i) { -%>
    signal input s<%- c %>_sv_root<%- i+1 %>Hash[4];
<%  } -%>
    signal input s<%- c %>_sv_rootQHash[4];
    signal input s<%- c %>_sv_evalsHash[4];
<%  for (let i = 1; i < stepsFRI.length; ++i) { -%>
    signal input s<%- c %>_s<%- i %>_rootHash[4];
<%  } -%>
    signal input s<%- c %>_sv_finalPolHash[4];
<%  } -%>
    
    signal output sv_circuitType;
    signal output sv_aggregationTypes[<%- nSubAirValues %>];
    signal output sv_subAirValues[<%- nSubAirValues %>][3];
    signal output sv_rootCHash[4];
<%  for (let i = 0; i < nChallengesStages.length; ++i) { -%>
    signal output sv_root<%- i+1 %>Hash[4];
<%  } -%>
    signal output sv_rootQHash[4];
    signal output sv_evalsHash[4];
<%      for(let i = 1; i < stepsFRI.length; i++) { -%>
    signal output sv_s<%- i %>_rootHash[4];
<%  } -%>
    signal output sv_finalPolHash[4];

<%  for(let i = 0; i < circuits.length; ++i) { -%>
<%      let c = circuits[i] -%>
    signal {binary} isNull<%- c %> <== IsZero()(s<%- c %>_circuitType);

    component sv<%- c %> = StarkVerifier();
    
    sv<%- c %>.enable <== 1 - isNull<%- c %>;

    sv<%- c %>.rootC <== SelectVerificationKey()(s<%- c %>_circuitType, rootCRecursive2);

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    sv<%- c %>.root<%- i+1 %> <== s<%- c %>_root<%- i + 1 %>;
<% } -%>
    sv<%- c %>.rootQ <== s<%- c %>_rootQ;

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    sv<%- c %>.s0_siblings<%- i+1 %> <== s<%- c %>_s0_siblings<%- i+1 %>;
<% } -%>
    sv<%- c %>.s0_siblingsQ <== s<%- c %>_s0_siblingsQ;
    sv<%- c %>.s0_siblingsC <== s<%- c %>_s0_siblingsC;

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    sv<%- c %>.s0_vals<%- i+1 %> <== s<%- c %>_s0_vals<%- i+1 %>;
<% } -%>
    sv<%- c %>.s0_valsQ <== s<%- c %>_s0_valsQ;
    sv<%- c %>.s0_valsC <== s<%- c %>_s0_valsC;

    sv<%- c %>.evals <== s<%- c %>_evals;
    
<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    sv<%- c %>.s<%- i %>_root <== s<%- c %>_s<%- i %>_root;
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    sv<%- c %>.s<%- i %>_siblings <== s<%- c %>_s<%- i %>_siblings;
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    sv<%- c %>.s<%- i %>_vals <== s<%- c %>_s<%- i %>_vals;
<% } -%>

    sv<%- c %>.finalPol <== s<%- c %>_finalPol;

<%  let nPublicsInps = 0; -%>
    sv<%- c %>.publics[<%- nPublicsInps++ %>] <== s<%- c %>_circuitType;

<%  if(nSubAirValues > 0) { -%>
    for(var i = 0; i < <%- nSubAirValues %>; i++) {
        sv<%- c %>.publics[<%- nPublicsInps++ %>] <== aggregationTypes[i];
    }

    for(var i = 0; i < <%- nSubAirValues %>; i++) {
        sv<%- c %>.publics[<%- nPublicsInps %> + 3*i] <== s<%- c %>_subAirValues[i][0];
        sv<%- c %>.publics[<%- nPublicsInps %> + 3*i + 1] <== s<%- c %>_subAirValues[i][1];
        sv<%- c %>.publics[<%- nPublicsInps %> + 3*i + 2] <== s<%- c %>_subAirValues[i][2];
    }
<%  nPublicsInps += 3*nSubAirValues; -%>
<%  } -%>

    for(var i = 0; i < 4; i++) {
        sv<%- c %>.publics[<%- nPublicsInps %> + i] <== s<%- c %>_sv_rootCHash[i];
    }
<%  nPublicsInps += 4 -%>

<%  for (let i = 0; i < nChallengesStages.length; i++) { -%>
    for(var i = 0; i < 4; i++) {
        sv<%- c %>.publics[<%- nPublicsInps %> + i] <== s<%- c %>_sv_root<%- i+1 %>Hash[i];
    }

<%  nPublicsInps += 4 -%>
<%  } -%>

    for(var i = 0; i < 4; i++) {
        sv<%- c %>.publics[<%- nPublicsInps %> + i] <== s<%- c %>_sv_rootQHash[i];
    }
<%  nPublicsInps += 4 -%>

    for(var i = 0; i < 4; i++) {
        sv<%- c %>.publics[<%- nPublicsInps %> + i] <== s<%- c %>_sv_evalsHash[i];
    }
<%  nPublicsInps += 4 -%>

<%  for(let i = 1; i < stepsFRI.length; i++) { -%>
    for(var i = 0; i < 4; i++) {
        sv<%- c %>.publics[<%- nPublicsInps %> + i] <== s<%- c %>_s<%- i %>_rootHash[i];
    }
<%  nPublicsInps += 4 -%>
<%  } -%>

    for(var i = 0; i < 4; i++) {
        sv<%- c %>.publics[<%- nPublicsInps %> + i] <== s<%- c %>_sv_finalPolHash[i];
    }
<%  nPublicsInps += 4 -%>

    for(var i = 0; i < <%- nPublics %>; i++) {
        sv<%- c %>.publics[<%- nPublicsInps %> + i] <== publics[i];
    }
<%  nPublicsInps += nPublics -%>

    for(var i = 0; i < <%- nChallengesStages.reduce((nc, acc) => nc + acc, 0) + 4 %>; i++) {
        sv<%- c %>.publics[<%- nPublicsInps %> + 3*i] <== challenges[i][0];
        sv<%- c %>.publics[<%- nPublicsInps %> + 3*i+1] <== challenges[i][1];
        sv<%- c %>.publics[<%- nPublicsInps %> + 3*i+2] <== challenges[i][2];
    }
<%  nPublicsInps += (nChallengesStages.reduce((nc, acc) => nc + acc, 0) + 4)*3; -%>

    for(var i = 0; i < <%- stepsFRI.length + 1 %>; i++) {
        sv<%- c %>.publics[<%- nPublicsInps %> + 3*i] <== challengesFRISteps[i][0];
        sv<%- c %>.publics[<%- nPublicsInps %> + 3*i+1] <== challengesFRISteps[i][1];
        sv<%- c %>.publics[<%- nPublicsInps %> + 3*i+2] <== challengesFRISteps[i][2];
    }
<%  nPublicsInps += (stepsFRI.length + 1)*3; -%>

for(var i = 0; i < 4; i++) {
    sv<%- c %>.publics[<%- nPublicsInps %> + i] <== rootCRecursive2[i];
}
<%  nPublicsInps += 4 -%>
<%  } -%>
    
    signal {binary} aggTypes[<%- nSubAirValues %>];
    for(var i = 0; i < <%- nSubAirValues %>; i++) {
        aggregationTypes[i] * (aggregationTypes[i] - 1) === 0;
        aggTypes[i] <== aggregationTypes[i];
    }

    sv_circuitType <== 1;
    sv_aggregationTypes <== aggTypes;
    for(var i = 0; i < <%- nSubAirValues %>; i++) {
        sv_subAirValues[i] <== AggregateSubAirValues()(sA_subAirValues[i], sB_subAirValues[i], isNullA, isNullB, aggTypes[i]);
    }
    sv_rootCHash <== AggregateValues()(sA_sv_rootCHash, sB_sv_rootCHash, isNullA, isNullB);
<%  for (let i = 0; i < nChallengesStages.length; ++i) { -%>
    sv_root<%- i+1 %>Hash <== AggregateValues()(sA_sv_root<%- i+1 %>Hash, sB_sv_root<%- i+1 %>Hash, isNullA, isNullB);
<%  } -%>
    sv_rootQHash <== AggregateValues()(sA_sv_rootQHash, sB_sv_rootQHash, isNullA, isNullB);
    sv_evalsHash <== AggregateValues()(sA_sv_evalsHash, sB_sv_evalsHash, isNullA, isNullB);
<%      for(let i = 1; i < stepsFRI.length; i++) { -%>
    sv_s<%- i %>_rootHash <== AggregateValues()(sA_s<%- i %>_rootHash, sB_s<%- i %>_rootHash, isNullA, isNullB);
<%  } -%>
    sv_finalPolHash <== AggregateValues()(sA_sv_finalPolHash, sB_sv_finalPolHash, isNullA, isNullB);
}

<% const publics = ["publics", "challenges", "challengesFRISteps", "rootCRecursive2"]; -%>

component main {public [<%- publics.join(",") %>]} = Main();
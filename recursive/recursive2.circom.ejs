pragma circom 2.1.0;
pragma custom_templates;

include mux2.circom;
include "<%- basicCircuitName %>.verifier.circom";

<% let vks = [[0,0,0,0], [1,1,1,1], [2,2,2,2]]; -%>

// Given a circuit type, return the corresponding verification key
template SelectVerificationKey() {

    // 0 -> Null
    // 2 -> Recursive2
    // 3 -> Basic1 (Recursive1)
    // 4 -> Basic2 (Recursive1)
    // ...
    signal input circuitType;

    // Recursive2 verification key. It needs to be provided as input because it is not known at compile time
    signal input rootCRecursive2[4];

    // Verification key corresponding to the circuit type
    signal output verificationKey[4];

    // Check that circuit type is valid value between 0 and N
    signal b0 <== circuitType * (circuitType - 1);
<% for(let i = 0; i < vks.length - 2; i++) { -%>
<%  if(i < vks.length - 3) { -%>
    signal b<%- i + 1 %> <=== b<% i %> * (circuitType - <%- i + 2 %>);
<%  } else { -%>
    b<%- i %> * (circuitType - <%- i + 2 %>) === 0;
<% } -%>
<% } -%>

    // The idea is to store an array of booleans which will indicate either 0 or 1 depending if the circuit type is equal to the index
    // For instance, [0,1,0,0] would mean that the circuit type is a recursive2.
    // Then, we will calculate the verification key as the sum of all the verification keys multiplied by the corresponding boolean
    signal isType[<%- vks.length %>];
<% for(let i = 0; i < vks.length; i++) { -%>
    isType[<%- i %>] <== IsZero()(<%- i %> - circuitType);
<% } -%>

    signal verificationKeys[<%- vks.length %>][4];
<% for(let i = 0; i < vks.length; i++) { -%>
<%      if(i === 1) { -%>
    verificationKeys[<%- i %>] <== rootCRecursive2;
<%      } else { -%>
    verificationKeys[<%- i %>] <== [<%- vks[i].join(', ') %>];
<%      } -%>
<% } -%>

    signal accVK[<%- vks.length %>][4];

    for(var i = 0; i < <%- vks.length %>; i++) {
        if(i == 0) {
            for(var j = 0; j < 4; j++) {
                accVK[i][j] <== isType[i]*verificationKeys[i][j] + accVK[i - 1][j];
            }
        } else {
            for(var j = 0; j < 4; j++) {
                accVK[i][j] <== isType[i]*verificationKeys[i][j] + accVK[i - 1][j];
            }
        }
    }

    verificationKey <== accVK[<%- vks.length - 1 %>];
}

template AggregateChallenges() {
    signal input challengeA[3];
    signal input isNullA; // 1 if is circuit type A is 0 (null), 0 otherwise

    signal input challengeB[3];
    signal input isNullB; // 1 if is circuit type B is 0 (null), 0 otherwise

    signal output challengeAB[3];

    // Calculate the hash of challengeA and challengeB
    signal hash <== Poseidon(12)()([challengeA[0], challengeA[1], challengeA[2], challengeB[0], challengeB[1], challengeB[2], 0, 0], [0,0,0,0]);
    signal hashAB[3] <== [hash[0], hash[1], hash[2]];

    // If circuit type A is null and circuit type B is null, then the challengeAB is 0
    // If circuit type A is not null and circuit type B is null, then the challengeAB is challengeA
    // If circuit type A is null and circuit type B is not null, then the challengeAB is challengeB
    // If circuit type A is not null and circuit type B is not null, then the challengeAB is hashAB

    signal values[3][4];
    values[0] <== [0, challengeA[0], challengeB[0], hashAB[0]];
    values[1] <== [0, challengeA[1], challengeB[1], hashAB[1]];
    values[2] <== [0, challengeA[2], challengeB[2], hashAB[2]];

    challengeAB <== MultiMux2(3)(values, [1 - isNullA, 1 - isNullB]);

}

template AggregateSubAirValues() {
    signal input subAirValueA[3];
    signal input isNullA; // 1 if is circuit type A is 0 (null), 0 otherwise 

    signal input subAirValueB[3];
    signal input isNullB; // 1 if is circuit type B is 0 (null), 0 otherwise 

    signal input aggregationType; // 1 if aggregation is multiplication, 0 if aggregation is addition

    signal output subAirValueAB[3];

    // If circuit type A is null, then its subAirValue is zero;
    signal valueA[3] <== [ (1 - isNullA)*subAirValueA[0], (1 - isNullA)*subAirValueA[1], (1 - isNullA)*subAirValueA[2] ];

    // If circuit type B is null, then its subAirValue is zero;
    signal valueB[3] <== [ (1 - isNullB)*subAirValueB[0], (1 - isNullB)*subAirValueB[1], (1 - isNullB)*subAirValueB[2] ];

    // Check tha aggregation type is either 0 or 1
    aggregationType * (aggregationType - 1) === 0;

    signal values[3][2];
    values[0] <== [valueA[0] + valueB[0], valueA[0] * valueB[0]];
    values[1] <== [valueA[1] + valueB[1], valueA[1] * valueB[1]];
    values[2] <== [valueA[2] + valueB[2], valueA[2] * valueB[2]];

    // Either add or multiply the subAirValues according to the aggregation type and then return the result
    subAirValueAB <== MultiMux1(3)(values, aggregationType);
}

template Main() {

    signal input publics[<%- starkInfo.nPublics %>];

<%  let nChallenges = starkInfo.numChallenges.reduce((curr, acc) => curr + acc, 0) + 4; -%>
    signal input challenges[<%- nChallenges %>][3];

<%  let nChallengesFRI = starkInfo.starkStruct.steps.length + 1; -%>
    signal input challengesFRISteps[<%- nChallengesFRI %>][3];

    signal input rootCRecursive2[4];

    signal input sA_circuitType;
    signal input sA_aggregationType;

    signal input sA_subAirValue[3];

<% for (let i = 0; i < starkInfo.numChallenges.length+1; ++i) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    signal input sA_root<%- index %>[4];
<% } -%>

<% for (let i = 0; i < starkInfo.numChallenges.length+1; ++i) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    signal input sA_s0_vals<%- index %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`cm${index}`] %>];
<% } -%>
    signal input sA_s0_valsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.nConstants %>];

<% for (let i = 0; i < starkInfo.numChallenges.length+1; ++i) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    signal input sA_s0_siblings<%- index %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];
<% } -%>
    signal input sA_s0_siblingsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];

    signal input sA_evals[<%- starkInfo.evMap.length %>][3];

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input sA_s<%- i %>_root[4];
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input sA_s<%- i %>_vals[<%- starkInfo.starkStruct.nQueries %>][<%- (1 << (starkInfo.starkStruct.steps[i-1].nBits - starkInfo.starkStruct.steps[i].nBits))*3 %>];
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input sA_s<%- i %>_siblings[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[i].nBits %>][4];
<% } -%>

    signal input sA_finalPol[<%- 1 << starkInfo.starkStruct.steps[starkInfo.starkStruct.steps.length-1].nBits %>][3];

    signal input sA_sv_publicsHash[3];
<%  for (let i = 0; i < starkInfo.numChallenges.length + 1; ++i) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    signal input sA_sv_root<%- index %>Hash[3];
<%  } -%>
    signal input sA_sv_evalsHash[3];
<%  for (let i = 0; i < starkInfo.starkStruct.steps.length; ++i) { -%>
    signal input sA_s<%- i %>_rootHash[3];
<%  } -%>
    signal input sA_sv_finalPolHash[3];

    
    signal input sB_circuitType;
    signal input sB_aggregationType;

    signal input sB_subAirValue[3];

<% for (let i = 0; i < starkInfo.numChallenges.length+1; ++i) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    signal input sB_root<%- index %>[4];
<% } -%>

<% for (let i = 0; i < starkInfo.numChallenges.length+1; ++i) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    signal input sB_s0_vals<%- index %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.mapSectionsN[`cm${index}`] %>];
<% } -%>
    signal input sB_s0_valsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.nConstants %>];

<% for (let i = 0; i < starkInfo.numChallenges.length+1; ++i) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    signal input sB_s0_siblings<%- index %>[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];
<% } -%>
    signal input sB_s0_siblingsC[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[0].nBits %>][4];

    signal input sB_evals[<%- starkInfo.evMap.length %>][3];

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input sB_s<%- i %>_root[4];
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input sB_s<%- i %>_vals[<%- starkInfo.starkStruct.nQueries %>][<%- (1 << (starkInfo.starkStruct.steps[i-1].nBits - starkInfo.starkStruct.steps[i].nBits))*3 %>];
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal input sB_s<%- i %>_siblings[<%- starkInfo.starkStruct.nQueries %>][<%- starkInfo.starkStruct.steps[i].nBits %>][4];
<% } -%>

    signal input sB_finalPol[<%- 1 << starkInfo.starkStruct.steps[starkInfo.starkStruct.steps.length-1].nBits %>][3];

    signal input sB_sv_publicsHash[3];
<%  for (let i = 0; i < starkInfo.numChallenges.length + 1; ++i) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    signal input sB_sv_root<%- index %>Hash[3];
<%  } -%>
    signal input sB_sv_evalsHash[3];
<%  for (let i = 0; i < starkInfo.starkStruct.steps.length; ++i) { -%>
    signal input sB_s<%- i %>_rootHash[3];
<%  } -%>
    signal input sB_sv_finalPolHash[3];

    signal output sv_circuitType;
    signal output sv_aggregationType;
    signal output sv_subAirValue[3];
    signal output sv_publicsHash[3];
<%  for (let i = 0; i < starkInfo.numChallenges.length + 1; ++i) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    signal output sv_root<%- index %>Hash[3];
<%  } -%>
    signal output sv_evalsHash[3];
<%      for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    signal output sv_s<%- i %>_rootHash[3];
<%  } -%>
    signal output sv_finalPolHash[3];

    signal isNullA <== IsZero()(sA_circuitType);
    signal isNullB <== IsZero()(sB_circuitType);

    component svA = StarkVerifier();
    
    svA.enable <== 1 - isNullA;

    svA.rootC <== SelectVerificationKey()(sA_circuitType, rootCRecursive2);

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    svA.root<%- i+1 %> <== sA_root<%- i + 1 %>;
<% } -%>
    svA.rootQ <== sA_rootQ;

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    svA.s0_siblings<%- i+1 %> <== s0_siblings<%- i+1 %>;
<% } -%>
    svA.s0_siblingsQ <== sA_s0_siblingsQ;
    svA.s0_siblingsC <== sA_s0_siblingsC;

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    svA.s0_vals<%- i+1 %> <== sA_s0_vals<%- i+1 %>;
<% } -%>
    svA.s0_valsQ <== sA_s0_valsQ;
    svA.s0_valsC <== sA_s0_valsC;

    svA.evals <== sA_evals;
    
<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    svA.s<%- i %>_root <== sA_s<%- i %>_root;
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    svA.s<%- i %>_siblings <== sA_s<%- i %>_siblings;
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    svA.s<%- i %>_vals <== sA_s<%- i %>_vals;
<% } -%>

    svA.finalPol <== sA_finalPol;

    for(var i = 0; i < <%- starkInfo.nPublics %>; i++) {
        svA.publics[i] <== publics[i];
    }

<%  let nPublicsInpsA = starkInfo.nPublics; -%>
    for(var i = 0; i < 4; i++) {
        svA.publics[<%- nPublicsInpsA %> + i] <== rootCRecursive2[i];
    }
<%  nPublicsInpsA += 4 -%>

    for(var i = 0; i < <%- nChallenges %>; i++) {
        svA.publics[<%- starkInfo.nPublics %> + 3*i] <== challenges[i][0];
        svA.publics[<%- starkInfo.nPublics %> + 3*i+1] <== challenges[i][1];
        svA.publics[<%- starkInfo.nPublics %> + 3*i+2] <== challenges[i][2];
    }
<%  nPublicsInpsA += nChallenges*3; -%>

    for(var i = 0; i < <%- nChallengesFRI %>; i++) {
        svA.publics[<%- nPublicsInpsA %> + 3*i] <== challengesFRISteps[i][0];
        svA.publics[<%- nPublicsInpsA %> + 3*i+1] <== challengesFRISteps[i][1];
        svA.publics[<%- nPublicsInpsA %> + 3*i+2] <== challengesFRISteps[i][2];
    }
<%  nPublicsInpsA += nChallengesFRI*3; -%>

    svA.publics[<%- nPublicsInpsA++ %>] <== sA_circuitType;
    svA.publics[<%- nPublicsInpsA++ %>] <== sA_aggregationType;

    for(var i = 0; i < 3; i++) {
        svA.publics[<%- nPublicsInpsA %> + i] <== sA_subAirValue[i];
    }
<%  nPublicsInpsA += 3 -%>

    svA.publics[<%- nPublicsInpsA++ %>] <== sA_sv_publicsHash[0];
    svA.publics[<%- nPublicsInpsA++ %>] <== sA_sv_publicsHash[1];
    svA.publics[<%- nPublicsInpsA++ %>] <== sA_sv_publicsHash[2];

<%  for (let i = 0; i < starkInfo.numChallenges.length + 1; i++) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    for(var i = 0; i < 3; i++) {
        svA.publics[<%- nPublicsInpsA %> + i] <== sA_sv_root<%- index %>Hash[i];
    }

<%  nPublicsInpsA += 3 -%>
<%  } -%>
    svA.publics[<%- nPublicsInpsA++ %>] <== sA_sv_evalsHash[0];
    svA.publics[<%- nPublicsInpsA++ %>] <== sA_sv_evalsHash[1];
    svA.publics[<%- nPublicsInpsA++ %>] <== sA_sv_evalsHash[2];

<%  for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    for(var i = 0; i < 3; i++) {
        svA.publics[<%- nPublicsInpsA %> + i] <== sA_s<%- i %>_rootHash[i];
    }

<%  nPublicsInpsA += 3 -%>
<%  } -%>
    svA.publics[<%- nPublicsInpsA++ %>] <== sA_sv_finalPolHash[0];
    svA.publics[<%- nPublicsInpsA++ %>] <== sA_sv_finalPolHash[1];
    svA.publics[<%- nPublicsInpsA++ %>] <== sA_sv_finalPolHash[2];
    
    component svB = StarkVerifier();

    svB.enable <== 1 - isNullB;

    svB.rootC <== SelectVerificationKey()(sB_circuitType, rootCRecursive2);

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    svB.root<%- i+1 %> <== sB_root<%- i + 1 %>;
<% } -%>
    svB.rootQ <== sB_rootQ;

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    svB.s0_siblings<%- i+1 %> <== s0_siblings<%- i+1 %>;
<% } -%>
    svB.s0_siblingsQ <== sB_s0_siblingsQ;
    svB.s0_siblingsC <== sB_s0_siblingsC;

<% for (let i = 0; i < starkInfo.numChallenges.length; ++i) { -%>
    svB.s0_vals<%- i+1 %> <== sB_s0_vals<%- i+1 %>;
<% } -%>
    svB.s0_valsQ <== sB_s0_valsQ;
    svB.s0_valsC <== sB_s0_valsC;

    svB.evals <== sB_evals;
    
<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    svB.s<%- i %>_root <== sB_s<%- i %>_root;
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    svB.s<%- i %>_siblings <== sB_s<%- i %>_siblings;
<% } -%>

<% for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    svB.s<%- i %>_vals <== sB_s<%- i %>_vals;
<% } -%>

    svB.finalPol <== sB_finalPol;

    for(var i = 0; i < <%- starkInfo.nPublics %>; i++) {
        svB.publics[i] <== publics[i];
    }

<%  let nPublicsInpsB = starkInfo.nPublics; -%>
    for(var i = 0; i < 4; i++) {
        svB.publics[<%- nPublicsInpsB %> + i] <== rootCRecursive2[i];
    }
<%  nPublicsInpsB += 4 -%>

    for(var i = 0; i < <%- nChallenges %>; i++) {
        svB.publics[<%- starkInfo.nPublics %> + 3*i] <== challenges[i][0];
        svB.publics[<%- starkInfo.nPublics %> + 3*i+1] <== challenges[i][1];
        svB.publics[<%- starkInfo.nPublics %> + 3*i+2] <== challenges[i][2];
    }
<%  nPublicsInpsB += nChallenges*3; -%>

    for(var i = 0; i < <%- nChallengesFRI %>; i++) {
        svB.publics[<%- nPublicsInpsB %> + 3*i] <== challengesFRISteps[i][0];
        svB.publics[<%- nPublicsInpsB %> + 3*i+1] <== challengesFRISteps[i][1];
        svB.publics[<%- nPublicsInpsB %> + 3*i+2] <== challengesFRISteps[i][2];
    }
<%  nPublicsInpsB += nChallengesFRI*3; -%>

    svB.publics[<%- nPublicsInpsB++ %>] <== sB_circuitType;
    svB.publics[<%- nPublicsInpsB++ %>] <== sB_aggregationType;

    for(var i = 0; i < 3; i++) {
        svB.publics[<%- nPublicsInpsB %> + i] <== sB_subAirValue[i];
    }
<%  nPublicsInpsB += 3 -%>

    svB.publics[<%- nPublicsInpsB++ %>] <== sB_sv_publicsHash[0];
    svB.publics[<%- nPublicsInpsB++ %>] <== sB_sv_publicsHash[1];
    svB.publics[<%- nPublicsInpsB++ %>] <== sB_sv_publicsHash[2];

<%  for (let i = 0; i < starkInfo.numChallenges.length + 1; i++) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    for(var i = 0; i < 3; i++) {
        svB.publics[<%- nPublicsInpsB %> + i] <== sB_sv_root<%- index %>Hash[i];
    }

<%  nPublicsInpsB += 3 -%>
<%  } -%>
    svB.publics[<%- nPublicsInpsB++ %>] <== sB_sv_evalsHash[0];
    svB.publics[<%- nPublicsInpsB++ %>] <== sB_sv_evalsHash[1];
    svB.publics[<%- nPublicsInpsB++ %>] <== sB_sv_evalsHash[2];

<%  for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    for(var i = 0; i < 3; i++) {
        svB.publics[<%- nPublicsInpsB %> + i] <== sB_s<%- i %>_rootHash[i];
    }

<%  nPublicsInpsB += 3 -%>
<%  } -%>
    svB.publics[<%- nPublicsInpsB++ %>] <== sB_sv_finalPolHash[0];
    svB.publics[<%- nPublicsInpsB++ %>] <== sB_sv_finalPolHash[1];
    svB.publics[<%- nPublicsInpsB++ %>] <== sB_sv_finalPolHash[2];

    sA_aggregationType === sB_aggregationType;

    sv_circuitType <== 1;
    sv_aggregationType <== sA_aggregationType;
    sv_subAirValue[3] <== AggregateSubAirValues()(sA_subAirValue, isNullA, sB_subAirValue, isNullB, sA_aggregationType);
    sv_publicsHash[3] <== AggregateChallenges()(sA_sv_publicsHash, isNullA, sB_sv_publicsHash, isNullB);
<%  for (let i = 0; i < starkInfo.numChallenges.length + 1; ++i) { -%>
<%      let index = i === starkInfo.numChallenges.length ? 'Q' : i+1; -%>
    sv_root<%- index %>Hash[3] <== AggregateChallenges()(sA_sv_root<%- index %>Hash, isNullA, sB_sv_root<%- index %>Hash, isNullB);
<%  } -%>
    sv_evalsHash[3] <== AggregateChallenges()(sA_sv_evalsHash,isNullA, sB_sv_evalsHash,isNullB);
<%      for(let i = 1; i < starkInfo.starkStruct.steps.length; i++) { -%>
    sv_s<%- i %>_rootHash[3] <== AggregateChallenges()(sA_s<%- i %>_rootHash, isNullA, sB_s<%- i %>_rootHash, isNullB);
<%  } -%>
    sv_finalPolHash[3] <== AggregateChallenges()(sA_sv_finalPolHash,isNullA, sB_sv_finalPolHash,isNullB);
}

<% const publics = ["publics", "rootCRecursive2", "challenges", "challengesFRISteps"]; -%>

component main {public [<%- publics.join(",") %>]} = Main();